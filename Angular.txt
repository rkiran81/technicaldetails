Loading an Angular app involves several stages, starting from the initial request to the server and ending with the app 
being fully operational in the browser. Here's a detailed overview of the process:

### 1. Initial Request and Index.html

When a user navigates to an Angular application, the browser makes an HTTP request to the server. The server responds 
with the `index.html` file, which is the entry point of the Angular app.

### 2. Loading of Index.html

The `index.html` file contains the basic HTML structure and a `<base>` tag to specify the base URL for routing. It also includes a `<script>` tag to load the main JavaScript bundle generated by the Angular build process.

**Example `index.html`**:
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Angular App</title>
  <base href="/">
</head>
<body>
  <app-root></app-root>
  <script src="main.js"></script> <!-- Angular bundle -->
</body>
</html>
```

### 3. JavaScript Bundle and Angular Bootstrapping

The main JavaScript bundle (e.g., `main.js`) contains the compiled Angular application code. 
It includes all the components, services, and dependencies. 
This bundle is loaded into the browser, and Angular bootstraps the application by initializing the root module 
(usually `AppModule`).

**Example Root Module (`AppModule`)**:
```typescript
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

### 4. Angular CLI Configuration

The Angular CLI (`angular.json`) specifies the entry point for the application and how the build process should be configured.
 It defines the source files, output path, and other build options.

**Example `angular.json`**:
```json
{
  "projects": {
    "my-app": {
      "architect": {
        "build": {
          "options": {
            "outputPath": "dist/my-app",
            "index": "src/index.html",
            "main": "src/main.ts",
            "polyfills": "src/polyfills.ts",
            "tsConfig": "tsconfig.app.json",
            ...
          }
        }
      }
    }
  }
}
```

### 5. Component Rendering

The Angular framework starts rendering the components specified in the root module. The root component (`AppComponent`) is rendered first and serves as the entry point for other components.

**Example Root Component (`AppComponent`)**:
```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'my-app';
}
```

### 6. Dependency Injection and Services

Angular uses dependency injection to provide services and dependencies to components. Services are registered with the root injector, making them available throughout the application.

### 7. Router Configuration

If the application uses Angular Router for navigation, the router configuration is initialized, and the appropriate components are displayed based on the current route.

**Example Router Configuration**:
```typescript
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { AboutComponent } from './about/about.component';

const routes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'about', component: AboutComponent }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```

### Summary

1. **Initial Request**: Browser requests `index.html` from the server.
2. **Loading `index.html`**: HTML file is loaded with the `<app-root>` element and a script tag for the Angular bundle.
3. **JavaScript Bundle**: The Angular bundle (`main.js`) is loaded, containing the compiled app code.
4. **Angular Bootstrapping**: The root module (`AppModule`) is initialized, bootstrapping the app.
5. **Component Rendering**: The root component (`AppComponent`) and other components are rendered.
6. **Dependency Injection**: Services and dependencies are provided to components via dependency injection.
7. **Router Configuration**: If applicable, the router is initialized, and the appropriate components are displayed based on the current route.

This process ensures that the Angular application loads efficiently and is fully operational in the browser. If you have any more questions or need further details, feel free to ask!

Sure! Let's dive into each of these Angular concepts:

### One-Way and Two-Way Data Binding

**One-Way Data Binding**:
- **Definition**: Data flows from the component to the view or from the view to the component, but not both ways simultaneously.
- **Usage**:
  - Component to View: Using interpolation (`{{ expression }}`) or property binding (`[property]="expression"`).
  - View to Component: Using event binding (`(event)="handler()"`).

**Example**:
```html
<!-- Component to View -->
<p>{{ title }}</p>
<!-- View to Component -->
<input (input)="onInput($event)" />
```

**Two-Way Data Binding**:
- **Definition**: Data flows bidirectionally between the component and the view. Changes in the view are reflected in the 
component, and vice versa.
- **Usage**: Achieved using the `[(ngModel)]` directive.

**Example**:
```html
<input [(ngModel)]="title" />
```

### @Input and @Output

**@Input**:
- **Definition**: Used to pass data from a parent component to a child component.
- **Usage**: Decorate a property in the child component with `@Input`.

**Example**:
```typescript
// Child Component
import { Input } from '@angular/core';

export class ChildComponent {
  @Input() data: string;
}
```

**@Output**:
- **Definition**: Used to send data from a child component to a parent component.
- **Usage**: Decorate an `EventEmitter` property in the child component with `@Output`.

**Example**:
```typescript
// Child Component
import { Output, EventEmitter } from '@angular/core';

export class ChildComponent {
  @Output() event = new EventEmitter<string>();

  triggerEvent() {
    this.event.emit('data');
  }
}
```

### @ViewChild

**Definition**: Used to access a child component, directive, or DOM element from the parent component.

**Usage**: Decorate a property in the parent component with `@ViewChild`.

**Example**:
```typescript
import { ViewChild } from '@angular/core';

export class ParentComponent {
  @ViewChild(ChildComponent) child: ChildComponent;

  ngAfterViewInit() {
    console.log(this.child.data);
  }
}
```

### @Viewport

**Definition**: This is often used to reference the viewport in the context of Angular animations or rendering content within a specific area of the view. It's not a direct Angular decorator but rather a concept.

### Promises and Observables

**Promises**:
- **Definition**: Represents a single future value. It's used for asynchronous operations that will complete in the future.
- **Usage**: `then` and `catch` methods.

**Example**:
```typescript
const promise = new Promise((resolve, reject) => {
  resolve('data');
});
promise.then(data => console.log(data));
```

**Observables**:
- **Definition**: Represents a stream of values over time. It's part of RxJS and used for handling asynchronous operations and event handling.
- **Usage**: `subscribe` method.

**Example**:
```typescript
import { Observable } from 'rxjs';

const observable = new Observable(observer => {
  observer.next('data');
});
observable.subscribe(data => console.log(data));
```

### Async/Await

**Definition**: Simplifies working with promises by allowing asynchronous code to be written in a synchronous-like manner.

**Usage**: `async` functions and `await` expressions.

**Example**:
```typescript
async function fetchData() {
  const data = await promise;
  console.log(data);
}
```

### EventEmitters

**Definition**: Used to create custom events that components can emit and listen to.

**Usage**: Commonly used with the `@Output` decorator.

**Example**:
```typescript
import { EventEmitter } from '@angular/core';

export class ChildComponent {
  @Output() customEvent = new EventEmitter<string>();

  triggerEvent() {
    this.customEvent.emit('data');
  }
}
```

These concepts are foundational to building robust and dynamic Angular applications. If you have any more questions or need further details, feel free to ask!


// http.service.ts
import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class HttpService {
  private baseUrl = 'https://api.example.com'; // Replace with your API base URL

  constructor(private http: HttpClient) {}

  // GET method
  get<T>(url: string): Observable<T> {
    return this.http.get<T>(`${this.baseUrl}${url}`).pipe(
      catchError(this.handleError)
    );
  }

  // POST method
  post<T>(url: string, data: any): Observable<T> {
    return this.http.post<T>(`${this.baseUrl}${url}`, data).pipe(
      catchError(this.handleError)
    );
  }

  // PUT method
  put<T>(url: string, data: any): Observable<T> {
    return this.http.put<T>(`${this.baseUrl}${url}`, data).pipe(
      catchError(this.handleError)
    );
  }

  // DELETE method
  delete<T>(url: string): Observable<T> {
    return this.http.delete<T>(`${this.baseUrl}${url}`).pipe(
      catchError(this.handleError)
    );
  }

  // Error handling
  private handleError(error: HttpErrorResponse) {
    let errorMessage = 'An unknown error occurred!';
    if (error.error instanceof ErrorEvent) {
      // Client-side or network error
      errorMessage = `Error: ${error.error.message}`;
    } else {
      // Server-side error
      errorMessage = `Error Code: ${error.status}\nMessage: ${error.message}`;
    }
    return throwError(errorMessage);
  }
}





// example.component.ts
import { Component, OnInit } from '@angular/core';
import { HttpService } from '../services/http.service';

@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
  styleUrls: ['./example.component.css']
})
export class ExampleComponent implements OnInit {
  data: any;

  constructor(private httpService: HttpService) {}

  ngOnInit() {
    this.getData();
  }

  getData() {
    this.httpService.get('/endpoint').subscribe(
      response => {
        this.data = response;
      },
      error => {
        console.error('Error fetching data', error);
      }
    );
  }
}



Directives are a core feature in Angular that allow you to attach behavior to elements in the DOM. They enable you to manipulate the DOM and extend its capabilities by adding custom behaviors to HTML elements.

### Types of Directives

1. **Component Directives**:
   - Components are directives with a template. They are the most common directive type and are used to create reusable UI components.
   - **Example**:
     ```typescript
     @Component({
       selector: 'app-example',
       templateUrl: './example.component.html',
       styleUrls: ['./example.component.css']
     })
     export class ExampleComponent {
       // Component logic
     }
     ```

2. **Structural Directives**:
   - Structural directives change the DOM layout by adding or removing elements. They are denoted by a `*` prefix.
   - **Example**: `ngIf`, `ngFor`, `ngSwitch`
     ```html
     <div *ngIf="condition">Conditionally rendered content</div>
     <ul>
       <li *ngFor="let item of items">{{ item }}</li>
     </ul>
     ```

3. **Attribute Directives**:
   - Attribute directives change the appearance or behavior of an element. They do not add or remove elements but can manipulate the DOM attributes.
   - **Example**: `ngClass`, `ngStyle`
     ```html
     <div [ngClass]="{'highlight': isHighlighted}">Styled content</div>
     ```

### Creating Custom Directives

You can create your own custom directives to encapsulate reusable behaviors.

**Example of a Custom Attribute Directive**:

1. **Generate the Directive**:
   ```sh
   ng generate directive directives/highlight
   ```

2. **Implement the Directive**:
   ```typescript
   // highlight.directive.ts
   import { Directive, ElementRef, Renderer2, HostListener } from '@angular/core';

   @Directive({
     selector: '[appHighlight]'
   })
   export class HighlightDirective {
     constructor(private el: ElementRef, private renderer: Renderer2) {}

     @HostListener('mouseenter') onMouseEnter() {
       this.renderer.setStyle(this.el.nativeElement, 'background-color', 'yellow');
     }

     @HostListener('mouseleave') onMouseLeave() {
       this.renderer.removeStyle(this.el.nativeElement, 'background-color');
     }
   }
   ```

3. **Use the Directive**:
   ```html
   <p appHighlight>Hover over this text to see the highlight effect</p>
   ```

### Summary

- **Component Directives**: Create reusable UI components with a template.
- **Structural Directives**: Alter the DOM structure by adding or removing elements (`ngIf`, `ngFor`).
- **Attribute Directives**: Change the appearance or behavior of an element (`ngClass`, `ngStyle`).

Angular directives provide a powerful way to create reusable, maintainable, and testable code by extending the capabilities of the DOM.

If you have any more questions or need further details, feel free to ask!




													ANGULAR ARCHITECTURE
Modules - group related components,services etc and can import them into another module
												
Root Module
	parent module of the app.solely responsible for bootstraping the application.
Feature Module
	group individual features. invertory module, billing module, shooping cart module
Shared Module
	to avoid code duplication. common services or functions that can be imported where ever required
Core Module
	generally our apps will have one core module which provides singleton services to our application
	singleton services
		services that must be instantiated only once or only exist once. example authentication service
		
Components (standalone)
	usually components encapsulate html, css and typescript to generate a particular view
	
standalone components do not have to be included within a module
import their dependencies directly using import statementin the file
used to architect smaller, simpler angular apps


Services
	encapsulate business logic or some fucntions
		utility functions/shared code 
		business logic
		backend,data access code like http
	imported by modules or by other standalone components
	
	
	
===================================================
https://app.pluralsight.com/ilx/video-courses/d5d30ea4-0af1-447a-b13a-e60a095337a6/0491e5a0-c6fd-4bfd-827b-27b85663a75a/e1ccbe1a-0053-4445-8ed8-6775804c9008
node -v
npm -v
npm i -g @angular/cli@16.0.0
ng v
ng g c home

git clone https://github.com/jmcooper/joes-robot-shop.git

decorator - are javascript concepts to add metadata to your class. e.g @Component

<app-home></app-home>	correct
<app-home/>					wrong

app-home - app is the prefix. must be unique. so we can change this prefixin angular.json which helps cli
in angular json find this "prefix": "app", and change the value appropriately

images by default will be loaded from src/assets because this is configured by cli in angular.json.
and we can add our custom paths into assets array like say "src/app/home/images" but when you access leave off "src/" from 
path

component lifecycle

ONCE					WHEN INPUT DATA CHANGES
OnInit					OnChanges
AfterContentInit		DoCheck
AfterViewInit			AfterContentChecked
OnDestroy				AfterViewChecked	


										ANGULAR TEMPLATE SYNTAX
Interpolation	
	<h1> 2 + 2 = </h1> displays 2 + 2 =
	<h1> 2 + 2 = {{2 + 2}} </h1> displays 2 + 2 = 4
	alt = "{{product.name}}"
	
Attribute Binding
	we use brackets to bind to expressions. expressions are evaluated and return a new value
	[alt] = "product.name" - one way, from component class to html
	[src] = "getImageUrl(product)" - 
	
Angular Directives
	only recognized by angular *ngFor, *ngIf, ngClass
	structural directive have asterisk meaning they change the structure of html - *ngFor, *ngIf
	
	<ul class="products">
      <li class="product-item" *ngFor="let product of getFilteredProduct()">
        <div class="product">
          <div class="product-details">
            <!-- <img src="{{ '/assets/images/robot-parts/' + product.imageName }}" alt="{{ product.na }}" /> -->
            <!-- <img [src]="'/assets/images/robot-parts/' + product.imageName" [alt]="product.name" /> -->
            <img [src]="getImageUrl(product)" [alt]="product.name" />
            <div class="product-info">
              <div class="name"> {{ product.name }}</div>
              <div class="description"> {{ product.description }}</div>
              <div class="category">Part Type: {{ product.category }}</div>
            </div>
          </div>
	
	<div *ngIf="product.discount === 0">${{ product.price.toFixed(2) }}</div>
	<div class="discount" *ngIf="product.discount > 0"> ${{ (product.price * (1 - product.discount)).toFixed(2) }} </div>
	
Event Binding
	we use parathesis to bind to statements. statemenst return no value but typically change state of the application
	(click) = "filter='Heads'" = one way, from html to component class.
	
										Handling null values with a SAFE NAVIGATION OPERATORs
say we are displaying array of products name and description like {{product.name}} and {{product.description}} using ul/li
and one of product is null. the moment null object is encounterd {{product.name}} will faill with cannot read properties
of null and html display is interrupted. so we can have product != null checks.but this isnot clean and cumbersome.
Angular provides a better way to handle this using SAFE NAVIGATION OPERATOR as below	

{{product?.name}} and {{product?.description}}.this is also valid {{shipping?.address?.city}}

product!: Iproduct;

! - tells compiler to ignore if product is not initialized
										PIPES FOR FORMATTING DATA
<div *ngIf="product.discount === 0">${{ product.price.toFixed(2) }}</div>
<div class="discount" *ngIf="product.discount > 0"> ${{ (product.price * (1 - product.discount)).toFixed(2) }} </div>

<div *ngIf="product.discount === 0">{{ product.price | currency }}</div>
<div class="discount" *ngIf="product.discount > 0"> {{ (product.price * (1 - product.discount)) | currency }} </div>
Now displays dollar symbol.

to display in pound
<div *ngIf="product.discount === 0">{{ product.price | currency:'GBP' }}</div>
<div class="discount" *ngIf="product.discount > 0"> {{ (product.price * (1 - product.discount)) | currency:'GBP' }} </div>

import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'capitalizeFirst'
})
export class CapitalizeFirstPipe implements PipeTransform {
  transform(value: string): string {
    if (!value) {
      return value;
    }
    return value.charAt(0).toUpperCase() + value.slice(1).toLowerCase();
  }
}
<p>{{ 'hello world' | capitalizeFirst }}</p>

import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'multiParam'
})
export class MultiParamPipe implements PipeTransform {
  transform(value: number, decimalPlaces: number, currencySymbol: string): string {
    if (isNaN(value)) {
      return value.toString();
    }
    return currencySymbol + value.toFixed(decimalPlaces);
  }
}
<p>{{ 1234.5678 | multiParam:2:'$' }}</p>
$1234.57																
	
	
										STYLING ANGULAR COMPONENTS
Applictaion-wide styling										
CSS encapsulation - providing css for a particular component.
	any css in particular component css file get applied to only that component
ngClass and ngStyle changes style as state changes
	<div [ngClass]="{strikethrough : product.discount > 0}">{{ product.price | currency:'GBP' }}</div>
	<div [ngClass]="getCSSClasses(product)">{{ product.price | currency:'GBP' }}</div>
	getCSSClasses(product: Iproduct){
		return {strikethrough : product.discount > 0};
		if(product.discount > 0)
			return 'strikethrough'
		else
			return ''
		if(product.discount > 0)
			return 'strikethrough bold'
		else
			return ''
		if(product.discount > 0)
			return ['strikethrough', 'bold']
		else
			return []
	}
	
ngStyle
	<div [style.color]="'red'" [ngClass]="getCSSClasses(product)">{{ product.price | currency:'GBP' }}</div>
	
	<div [style.color]="product.discount  > 0 ? 'red' : ''" 
		[ngClass]="getCSSClasses(product)">{{ product.price | currency:'GBP' }}</div>
		
	<div [ngStyle]="{'color': product.discount  > 0 ? 'red' : '' }" 
		[ngClass]="getCSSClasses(product)">{{ product.price | currency:'GBP' }}</div>
	
CSS framework - third party css library like saas (.scss), bootstrap, tailwind	
										
										COMMUNICATING BETWEEN ANGULAR COMPONENTS
One way communication Parent component to child component

Parent   --  data  ->>    Child		@Input send data to child
Parent   <<- event --    Child		@Output send events to parent		

Parent
	<li class="product-item" *ngFor="let product of getFilteredProduct()">
		<bot-product-detail [product]="product"></bot-product-detail>
	</li>
Child
	@Input() product!: Iproduct;	


										CREATING AND USING ANGULAR SERVICES
default dependency injection
	1.create service
		export class LoginService{}
	2. dependency inject
		export class LoginComponent(){
			constructor(private loginsvc: LoginService){}
			
			handleLogin(){
				this.loginsvc.login();
			}
		}
		
inject function		
	do not use constructor injection rather
	private cartService: CartService = inject(CartService); //inject is from @angular/core. issues in unit test
	
	
	
										HTTP
Observables
	dealing with asynchronous data
	let observe = getSomeData();
	observe.subscribe({
		next: userData => {//process data},
		error: error => {//handle error},
		onComplete: () => {//handle complete}
	});
	observe.pipe(
		//modify data
	);
	
LEARN ABOUT PIPING STREAMS OF DATA

SOURCE           PIPE TO TRANSFORM          SUBSCRIBE

let obsv = from([1,2,3,4]);
let obsv = from(4);

obsv.pipe(
	map( num => num + 1);
);

obsv.subscribe( data => console.log(data));  //5


the obsevable we get from http do not have next method because once we receive data we dont need to emit anything

let behav = new BehaviorSubject<number>();

behav.subscribe(num => console.log(num));

behav.next(1); //this is when we need to create our own observable and add/emit data.
prints 1
behav.next(2);
prints 2
	
Proxy setup
GET
POST

											ROUTES
ng g m router --flat --module=app
const routes : Routes = [
	{path='home', component: HomeComponent,title: 'page title'},
	{path='catalog', component: CatalogComponent,title: 'page title'},
	{path='cart', component: CartComponent,title: 'page title'},
	{path='inventory/:id', component: CartComponent,title: 'page title'},   //path param is mandatory, queryParama optional
	{path: 'lazy', loadChildren: () => import('./lazy/lazy.module').then(m => m.LazyModule) }
	{path='', redirectTo:'/home', pathMatch:'full'},
];
RouterModule.forRoot(routes)	
export:[RouterModule]	

<router-outlet></router-outlet>		

<a routerLink='catalog' [queryParama] = {filter: 'heads'} routerActivate={cssclassname}>Heads	
<a routerLink='catalog' [queryParama] = {filter: 'Toros'} routerActivate={cssclassname}>Toros
<a routerLink='' routerActivate={cssclassname} routeeActivateOptions={exact:true}>	All

this.router.navigate(['/catalog']);	
this.route.queryParams.subscribe( (params) => {
	this.filterValue = params['filter'];
});		


												Angular Forms
Template driven
Reactive Forms	

Template driven
	import FormsModule

user.model.ts
export interface IUserCredentials{
	email: string;
	password: string
}	

component.ts
let credentials :IUserCredentials = {email : '', password : ''}
component.html
<input type="text" name="email" [(ngModel)] = "credentials.email"		//twoway binding. ngModel needs name attribute

<form name="xxxx" (ngSubmit)="signIn()">
<button type="submit" />
</form>


Template variables
	
